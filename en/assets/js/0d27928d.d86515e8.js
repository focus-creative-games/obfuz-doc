"use strict";(self.webpackChunkobfuz=self.webpackChunkobfuz||[]).push([[5415],{8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}},8735:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"manual/run-obfuscation-standalonely","title":"Run Obfuscation Standalone","description":"Sometimes it\'s necessary to run obfuscation outside of the build pipeline. For example, when using HybridCLR hot updates, you want to obfuscate the hot update code before releasing it.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/run-obfuscation-standalonely.md","sourceDirName":"manual","slug":"/manual/run-obfuscation-standalonely","permalink":"/en/docs/manual/run-obfuscation-standalonely","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manual/run-obfuscation-standalonely.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Obfuscation During Build Process","permalink":"/en/docs/manual/build-pipeline"},"next":{"title":"Incremental Obfuscation and Hot Update","permalink":"/en/docs/manual/incremental-obfuscation-and-hotupdate"}}');var s=n(4848),o=n(8453);const r={},a="Run Obfuscation Standalone",l={},u=[{value:"Generate DLLs to be Obfuscated",id:"generate-dlls-to-be-obfuscated",level:2},{value:"Code Implementation",id:"code-implementation",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"run-obfuscation-standalone",children:"Run Obfuscation Standalone"})}),"\n",(0,s.jsx)(t.p,{children:"Sometimes it's necessary to run obfuscation outside of the build pipeline. For example, when using HybridCLR hot updates, you want to obfuscate the hot update code before releasing it."}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["If you are using HybridCLR, strongly recommend using the ",(0,s.jsx)(t.code,{children:"com.cod-philosophy.obfuz4hybridclr"})," package, as it already provides all the code needed for HybridCLR hot updates, making it more convenient and simple to use.\nFor detailed documentation, see ",(0,s.jsx)(t.a,{href:"./hybridclr/work-with-hybridclr",children:"Working with HybridCLR"}),"."]})}),"\n",(0,s.jsx)(t.h2,{id:"generate-dlls-to-be-obfuscated",children:"Generate DLLs to be Obfuscated"}),"\n",(0,s.jsx)(t.p,{children:"Source code assemblies need to be compiled into dlls first before they can be obfuscated by Obfuz. For source code within Unity projects, you can use the following code to compile dlls:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'\npublic class ObfuscateTool\n{\n  public static void CompileDll(string buildDir, BuildTarget target, bool developmentBuild)\n  {\n    var group = BuildPipeline.GetBuildTargetGroup(target);\n\n    ScriptCompilationSettings scriptCompilationSettings = new ScriptCompilationSettings();\n    scriptCompilationSettings.group = group;\n    scriptCompilationSettings.target = target;\n    scriptCompilationSettings.options = developmentBuild ? ScriptCompilationOptions.DevelopmentBuild : ScriptCompilationOptions.None;\n    Directory.CreateDirectory(buildDir);\n    ScriptCompilationResult scriptCompilationResult = PlayerBuildInterface.CompilePlayerScripts(scriptCompilationSettings, buildDir);\n#if UNITY_2022\n    UnityEditor.EditorUtility.ClearProgressBar();\n#endif\n    Debug.Log($"compile finish!!! buildDir:{buildDir} target:{target} development:{developmentBuild}");\n  }\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"code-implementation",children:"Code Implementation"}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["Running obfuscation standalone will not trigger ",(0,s.jsx)(t.code,{children:"Obfuz.Unity.ObfuscationBeginEventArgs"})," and ",(0,s.jsx)(t.code,{children:"Obfuz.Unity.ObfuscationEndEventArgs"}),". These two events are only triggered in the build pipeline."]})}),"\n",(0,s.jsx)(t.p,{children:"Please compile the dlls first before obfuscation."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'\nusing HybridCLR.Editor;\nusing Obfuz.Settings;\nusing Obfuz;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEditor;\nusing HybridCLR.Editor.Commands;\nusing HybridCLR.Editor.Installer;\nusing System.IO;\nusing HybridCLR.Editor.ABI;\nusing UnityEngine;\n\n\npublic static class ObfuscateUtil\n{\n\n    public static void Obfuscate(BuildTarget target, List<string> assemblySearchPaths, string outputPath)\n    {\n        var obfuzSettings = ObfuzSettings.Instance;\n\n        var assemblySearchDirs = assemblySearchPaths;\n\n        // Default dll search paths do not include UnityEditor related assemblies.\n        // If the obfuscated assembly is only used in Editor and references UnityEditor related assemblies,\n        // then searchPathIncludeUnityEditorDll=true is needed\n        bool searchPathIncludeUnityEditorDll = false;\n        ObfuscatorBuilder builder = ObfuscatorBuilder.FromObfuzSettings(obfuzSettings, target, true, searchPathIncludeUnityEditorDll);\n        builder.InsertTopPriorityAssemblySearchPaths(assemblySearchDirs);\n\n        string obfuscatedAssemblyOutputPath = obfuzSettings.GetObfuscatedAssemblyOutputPath(target);\n\n        Obfuscator obfuz = builder.Build();\n        obfuz.Run();\n\n        Directory.CreateDirectory(outputPath);\n        foreach (string srcFile in Directory.GetFiles(obfuscatedAssemblyOutputPath, "*.dll"))\n        {\n            string fileName = Path.GetFileName(srcFile);\n            string destFile = $"{outputPath}/{fileName}";\n            File.Copy(srcFile, destFile, true);\n            Debug.Log($"Copy {srcFile} to {destFile}");\n        }\n    }\n}\n\n\n'})})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);