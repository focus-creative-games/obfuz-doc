"use strict";(self.webpackChunkobfuz=self.webpackChunkobfuz||[]).push([[4010],{922:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"manual/const-encryption","title":"Constant Encryption","description":"Encrypting constants that appear in code can effectively protect code security.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/const-encryption.md","sourceDirName":"manual","slug":"/manual/const-encryption","permalink":"/en/docs/manual/const-encryption","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manual/const-encryption.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Symbol Obfuscation","permalink":"/en/docs/manual/symbol-obfuscation"},"next":{"title":"Remove Const Fields","permalink":"/en/docs/manual/remove-const-field"}}');var i=t(4848),r=t(8453);const l={},c="Constant Encryption",d={},o=[{value:"Supported Constant Types",id:"supported-constant-types",level:2},{value:"Implementation Principle",id:"implementation-principle",level:2},{value:"Settings",id:"settings",level:2},{value:"Encryption Level",id:"encryption-level",level:2},{value:"Rule Files",id:"rule-files",level:2},{value:"whitelist",id:"whitelist",level:3},{value:"global",id:"global",level:3},{value:"assembly",id:"assembly",level:3},{value:"type",id:"type",level:3},{value:"method",id:"method",level:3}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"constant-encryption",children:"Constant Encryption"})}),"\n",(0,i.jsx)(n.p,{children:"Encrypting constants that appear in code can effectively protect code security."}),"\n",(0,i.jsx)(n.h2,{id:"supported-constant-types",children:"Supported Constant Types"}),"\n",(0,i.jsx)(n.p,{children:"Currently supports the following constant types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"byte, sbyte"}),"\n",(0,i.jsx)(n.li,{children:"short, ushort"}),"\n",(0,i.jsx)(n.li,{children:"int, uint"}),"\n",(0,i.jsx)(n.li,{children:"long, ulong"}),"\n",(0,i.jsx)(n.li,{children:"IntPtr, UIntPtr"}),"\n",(0,i.jsx)(n.li,{children:"float"}),"\n",(0,i.jsx)(n.li,{children:"double"}),"\n",(0,i.jsx)(n.li,{children:"string"}),"\n",(0,i.jsx)(n.li,{children:"array including all simple type arrays byte[], sbyte[], short[], ushort[], int[], uint[], long[], ulong[], float[], double[] and high-dimensional simple arrays (like float[,,])"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-principle",children:"Implementation Principle"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"EncryptionService<Scope>::Encrypt"})," to first calculate the encrypted value encryptedValue of the ",(0,i.jsx)(n.strong,{children:"constant"})]}),"\n",(0,i.jsx)(n.li,{children:"Save encryptedValue to rvaData (rva is a method in dll for storing large amounts of continuous data)."}),"\n",(0,i.jsxs)(n.li,{children:["Replace constants in code with ",(0,i.jsx)(n.code,{children:"EncryptionService<Scope>::DecryptFromRva{Int|Long|Float|Double|String|Bytes}(byte[] rvaData, int offset, [int length, ] int ops, int salt)"})," expressions."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"rvaData is also stored in encrypted form, meaning each constant requires two-step decryption when decrypted at runtime: first decrypt rvaData, then decrypt after reading encryptedValue from rvaData."}),"\n",(0,i.jsx)(n.h2,{id:"settings",children:"Settings"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ObfuzSettings.ConstEncryptSettings"})," contains constant encryption related settings, detailed documentation can be found in ",(0,i.jsx)(n.a,{href:"./configuration",children:"Configuration"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"encryption-level",children:"Encryption Level"}),"\n",(0,i.jsxs)(n.p,{children:["Encryption level affects the ",(0,i.jsx)(n.code,{children:"ops"})," parameter passed when calling ",(0,i.jsx)(n.code,{children:"EncryptionService<Scope>::DecryptFromRvaXX"}),". Detailed introduction about the ops parameter can be found in ",(0,i.jsx)(n.a,{href:"./encryption",children:"Encryption"})," documentation."]}),"\n",(0,i.jsxs)(n.p,{children:["Encryption level value range is ",(0,i.jsx)(n.code,{children:"[1-4]"}),". During encryption, the same number of ops as the encryption level value will be generated. Simply enabling constant encryption can effectively prevent cracking. The encryption level size doesn't significantly improve anti-cracking difficulty, so it's recommended to default to 1."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ConstEncryptSettings.EncryptionLevel"})," field can set the global default encryption level."]}),"\n",(0,i.jsx)(n.h2,{id:"rule-files",children:"Rule Files"}),"\n",(0,i.jsxs)(n.p,{children:["By default, Obfuz encrypts all constants, but also supports rule files to finely control the scope and effects of constant encryption. The ",(0,i.jsx)(n.code,{children:"ConstEncryptSettings.RuleFiles"})," option can configure 0-N rule files.\nRule file relative paths are from the project directory, valid rule file paths look like: ",(0,i.jsx)(n.code,{children:"Assets/XXX/YYY.xml"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Configuration example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\n<?xml version="1.0" encoding="UTF-8"?>\n\n<obfuz>\n\n    <whitelist type="int">1000,456</whitelist>\n    <whitelist type="long">100000000000,45600000000</whitelist>\n    <whitelist type="string">aaabbb</whitelist>\n    <whitelist type="int-range">-100,200</whitelist>\n    <whitelist type="long-range">-10000000000,20000000000</whitelist>\n    <whitelist type="float-range">-100,200</whitelist>\n    <whitelist type="double-range">-100,200</whitelist>\n    <whitelist type="string-length-range">,3</whitelist>\n    <whitelist type="array-length-range">1,3</whitelist>\n\n    <global disableEncrypt="0" encryptInt="1" encryptLong="1" encryptFloat="1" encryptDouble="1" encryptArray="1" encryptString="1"\n        encryptConstInLoop="1" encryptStringInLoop="1" cacheConstInLoop="1" cacheConstNotInLoop="0" cacheStringInLoop="1" cacheStringNotInLoop="1">\n    </global>\n    \n    <assembly name="Obfus1" cacheConstInLoop="1" cacheConstNotInLoop="0">\n        <type name="*">\n            <method name="*" cacheConstInLoop="1"/>\n        </type>\n      <type name="Aaaa.TopClass/SubClass">\n      </type>\n    </assembly>\n</obfuz>\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Top-level tag must be obfuz"}),"\n",(0,i.jsx)(n.li,{children:"Second-level tags can be whitelist, global and assembly"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"whitelist",children:"whitelist"}),"\n",(0,i.jsx)(n.p,{children:"Whitelist configures constant whitelists. Constants in the whitelist will not be encrypted. This setting takes effect for all assemblies."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"int"}),(0,i.jsxs)(n.td,{children:["int constant list, separated by ",(0,i.jsx)(n.code,{children:","}),", can be 0-N items."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"long"}),(0,i.jsxs)(n.td,{children:["long constant list, separated by ",(0,i.jsx)(n.code,{children:","}),", can be 0-N items."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"string"}),(0,i.jsxs)(n.td,{children:["String constant, can only fill one. Note that due to xml format itself, leading/trailing and middle whitespace characters will be ignored. Use escape characters ",(0,i.jsx)(n.code,{children:"&lt;"})," to represent these special fields."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"int-range"}),(0,i.jsxs)(n.td,{children:["int integer range, value range is a closed interval. For example ",(0,i.jsx)(n.code,{children:"100-100"})," represents ",(0,i.jsx)(n.code,{children:"[100, 100]"}),", i.e., all integers greater than or equal to 100 and less than or equal to 100. Supports empty lower or upper bounds, indicating no limit. Like ",(0,i.jsx)(n.code,{children:",100"})," represents all integers less than or equal to 100; ",(0,i.jsx)(n.code,{children:"100,"})," represents all integers greater than or equal to 100; ",(0,i.jsx)(n.code,{children:","})," represents all integers."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"long-range"}),(0,i.jsx)(n.td,{children:"long integer range, rules same as int-range."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"float-range"}),(0,i.jsx)(n.td,{children:"float range, rules same as int-range."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"double-range"}),(0,i.jsx)(n.td,{children:"double range, rules same as int-range."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"string-length-range"}),(0,i.jsx)(n.td,{children:"String length range, strings meeting this length range will not be encrypted. Rules same as int-range."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"array-length-range"}),(0,i.jsx)(n.td,{children:"Constant array length range, constant arrays meeting this length range will not be encrypted. Rules same as int-range."})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"global",children:"global"}),"\n",(0,i.jsx)(n.p,{children:"Global defines global default encryption parameters."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Nullable"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"disableEncrypt"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"0"}),(0,i.jsxs)(n.td,{children:["Whether to disable encryption, it has higher priority than options like ",(0,i.jsx)(n.code,{children:"encryptInt"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"encryptInt"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to enable int encryption"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"encryptLong"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to enable long encryption"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"encryptFloat"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to enable float encryption"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"encryptDouble"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to enable double encryption"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"encryptString"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to enable string encryption"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"encryptArray"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to enable constant array encryption. Since constant array encryption is not currently supported, this configuration has no actual effect"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"encryptConstInLoop"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsxs)(n.td,{children:["Whether to encrypt int, long, float, double type constants in loops. Since loops execute multiple times, encrypting constants in loops may significantly impact performance. For example ",(0,i.jsx)(n.code,{children:"for (int i = 0; i < 100; i++) { n += 100; }"})," will significantly reduce performance after enabling loop encryption"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"encryptStringInLoop"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to encrypt string type constants in loops."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"cacheConstInLoop"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to cache int, long, float, double type constants in loops. If cached, decrypted constants will be saved in a lazily decrypted static variable, and the runtime reads this static variable instead of performing decryption operations."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"cacheStringInLoop"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to cache string type constants in loops."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"cacheConstNotInLoop"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"0"}),(0,i.jsx)(n.td,{children:"Whether to cache constants not in loops."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"cacheStringNotInLoop"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to cache strings not in loops. Since decrypting strings each time produces GC, by default strings not in loops are also cached"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"assembly",children:"assembly"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Nullable"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Assembly name, must be in the obfuscated assembly list"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Others"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Inherit same-named options from global"}),(0,i.jsx)(n.td,{children:"All options in global can be used, if not defined, inherit the value of same-named option in global"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Assembly's child elements can only be type."}),"\n",(0,i.jsx)(n.h3,{id:"type",children:"type"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Nullable"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsxs)(n.td,{children:["Type name wildcard string, if empty means match all types. Nested types use ",(0,i.jsx)(n.code,{children:"/"})," to separate the declaring type and enclosed subtypes, like ",(0,i.jsx)(n.code,{children:"test.ClassA/ClassB"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Others"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Inherit same-named options from assembly"}),(0,i.jsx)(n.td,{children:"All options in global can be used, if not defined, inherit the value of same-named option in assembly"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Since constants can only appear in function code, type's child elements can only be method."}),"\n",(0,i.jsx)(n.h3,{id:"method",children:"method"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Nullable"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Type name wildcard string, if empty means match all types"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Others"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Inherit same-named options from assembly"}),(0,i.jsx)(n.td,{children:"All options in global can be used, if not defined, inherit the value of same-named option in assembly"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>c});var s=t(6540);const i={},r=s.createContext(i);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);