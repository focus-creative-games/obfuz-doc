"use strict";(self.webpackChunkobfuz=self.webpackChunkobfuz||[]).push([[1159],{6831:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"manual/reflection","title":"Reflection","description":"Symbol Obfuscation modifies the names of various metadata. This causes reflection lookups for types, functions, fields, etc. by name to fail.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/reflection.md","sourceDirName":"manual","slug":"/manual/reflection","permalink":"/en/docs/manual/reflection","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manual/reflection.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Serialization","permalink":"/en/docs/manual/serialization"},"next":{"title":"Impact on Assembly Size","permalink":"/en/docs/manual/impact-dll-size"}}');var s=i(4848),a=i(8453);const o={},l="Reflection",r={},c=[{value:"Special Support for Unity Built-in Serialization",id:"special-support-for-unity-built-in-serialization",level:2},{value:"Offline Detection of Reflection Code Compatibility Issues",id:"offline-detection-of-reflection-code-compatibility-issues",level:2},{value:"Runtime Reflection Support",id:"runtime-reflection-support",level:2},{value:"ObfuscationTypeMapper",id:"obfuscationtypemapper",level:3},{value:"ObfuscationInstincts",id:"obfuscationinstincts",level:3},{value:"Solving the Problem of Reflection Not Finding Types After Obfuscation",id:"solving-the-problem-of-reflection-not-finding-types-after-obfuscation",level:2},{value:"1. Disable Symbol Obfuscation for Metadata That Needs Reflection Lookup",id:"1-disable-symbol-obfuscation-for-metadata-that-needs-reflection-lookup",level:3},{value:"2. Use ObfuscationTypeMapper to Get Obfuscated Types by Original Class Names",id:"2-use-obfuscationtypemapper-to-get-obfuscated-types-by-original-class-names",level:3},{value:"3. Manually Maintain Mapping Between Original Names and Types",id:"3-manually-maintain-mapping-between-original-names-and-types",level:3}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"reflection",children:"Reflection"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"./symbol-obfuscation",children:"Symbol Obfuscation"})," modifies the names of various metadata. This causes reflection lookups for types, functions, fields, etc. by name to fail.\nTherefore, without special handling, these functions will not work properly after symbol obfuscation."]}),"\n",(0,s.jsx)(n.h2,{id:"special-support-for-unity-built-in-serialization",children:"Special Support for Unity Built-in Serialization"}),"\n",(0,s.jsx)(n.p,{children:"Obfuz is deeply integrated with Unity workflows and has built-in support for the following rules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Will not obfuscate type names and namespaces of MonoBehaviour, ScriptableObject, and types marked with ",(0,s.jsx)(n.code,{children:"[Serializable]"})," attribute"]}),"\n",(0,s.jsxs)(n.li,{children:["Will not obfuscate serialized fields of the above types, including private fields marked with ",(0,s.jsx)(n.code,{children:"[SerializedField]"})," attribute"]}),"\n",(0,s.jsx)(n.li,{children:"Will not obfuscate non-static public properties of the above types, but public static and non-public properties will still be obfuscated"}),"\n",(0,s.jsxs)(n.li,{children:["Will not obfuscate enum item names of enum types marked with ",(0,s.jsx)(n.code,{children:"[Serializable]"})," attribute"]}),"\n",(0,s.jsxs)(n.li,{children:["Will not obfuscate event functions with special purposes like ",(0,s.jsx)(n.code,{children:"Awake"}),", ",(0,s.jsx)(n.code,{children:"Start"})," in MonoBehavior"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["More rules can be found in the documentation ",(0,s.jsx)(n.a,{href:"./symbol-obfuscation",children:"Symbol Obfuscation"}),". Types not covered by default rules need to use the special solutions below."]}),"\n",(0,s.jsx)(n.h2,{id:"offline-detection-of-reflection-code-compatibility-issues",children:"Offline Detection of Reflection Code Compatibility Issues"}),"\n",(0,s.jsxs)(n.p,{children:["Obfuz supports detecting potentially failing code after symbol obfuscation and prints errors or warnings. For detailed documentation, see ",(0,s.jsx)(n.a,{href:"./symbol-obfuscation#detect-reflection-compatibility",children:"Detect Reflection Compatibility"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"runtime-reflection-support",children:"Runtime Reflection Support"}),"\n",(0,s.jsx)(n.h3,{id:"obfuscationtypemapper",children:"ObfuscationTypeMapper"}),"\n",(0,s.jsxs)(n.p,{children:["Obfuz provides ",(0,s.jsx)(n.code,{children:"Obfuz.ObfuscationTypeMapper"})," to maintain the mapping relationship from original type full names to types before obfuscation. ObfuscationTypeMapper provides the following interfaces:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Type GetTypeByOriginalFullName(Assembly assembly, string originalFullName)"})," Find Type by original type name."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"string GetOriginalTypeFullName(Type type)"})," Get the original type full name from Type."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"string GetOriginalTypeFullNameOrCurrent(Type type)"})," Get the original type full name from Type. If the type is not found in the registered mapping type dictionary, return the ",(0,s.jsx)(n.code,{children:"Type.FullName"})," value."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"obfuscationinstincts",children:"ObfuscationInstincts"}),"\n",(0,s.jsxs)(n.p,{children:["Obfuz provides ",(0,s.jsx)(n.a,{href:"./obfuscation-instincts",children:"ObfuscationInstincts"})," to get original type names."]}),"\n",(0,s.jsxs)(n.p,{children:["ObfuscationTypeMapper is used to get original type names when you only know the runtime ",(0,s.jsx)(n.code,{children:"Type"})," variable. If you know the specific type at the current location,\nObfuscationInstincts provides a more direct interface to get original type names without needing to register type mappings."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FullNameOf<T>"})," Returns the original type full name"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NameOf<T>"})," Returns the original type name without namespace"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"solving-the-problem-of-reflection-not-finding-types-after-obfuscation",children:"Solving the Problem of Reflection Not Finding Types After Obfuscation"}),"\n",(0,s.jsx)(n.h3,{id:"1-disable-symbol-obfuscation-for-metadata-that-needs-reflection-lookup",children:"1. Disable Symbol Obfuscation for Metadata That Needs Reflection Lookup"}),"\n",(0,s.jsx)(n.p,{children:"There are several ways:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Configure disabling ",(0,s.jsx)(n.code,{children:"Symbol Obfus"})," Pass for certain metadata in ",(0,s.jsx)(n.a,{href:"./obfuscation-pass",children:"Obfuscation Pass"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Configure disabling symbol obfuscation for certain metadata in the rule files of ",(0,s.jsx)(n.a,{href:"./symbol-obfuscation",children:"Symbol Obfuscation"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Add ",(0,s.jsx)(n.code,{children:"[ObfuzIgnore]"})," attribute to metadata that needs to disable symbol obfuscation in code, see documentation ",(0,s.jsx)(n.a,{href:"./customattributes",children:"Obfuz CustomAttributes"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-use-obfuscationtypemapper-to-get-obfuscated-types-by-original-class-names",children:"2. Use ObfuscationTypeMapper to Get Obfuscated Types by Original Class Names"}),"\n",(0,s.jsxs)(n.p,{children:["Obfuz provides ",(0,s.jsx)(n.code,{children:"Obfuz.ObfuscationTypeMapper"})," to maintain the mapping relationship from original type full names to types before obfuscation. Usage:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"ObfuscationInstincts.RegisterReflectionType<T>()"})," at startup to register types that need reflection lookup"]}),"\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"ObfuscationTypeMapper.GetTypeByOriginalFullName(assembly, originalFullName)"})," function to get types by original names"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'\n// Type that needs reflection lookup\nclass MyClassA\n{\n\n}\n\n// Type that needs reflection lookup\nclass MyClassB\n{\n\n}\n\nclass MyClass\n{\n  void OnInit()\n  {\n    // Register this mapping relationship at startup, must complete registration before calling ObfuscationTypeMapper.GetTypeByOriginalFullName\n    ObfuscationInstincts.RegisterReflectionType<MyClassA>();\n    ObfuscationInstincts.RegisterReflectionType<MyClassB>();\n    // ..\n  }\n\n  void Test()\n  {\n    // ObfuscationTypeMapper.GetTypeByOriginalFullName needs assembly parameter to indicate\n    // which assembly to search for this type\n    Assembly ass = typeof(MyClass).Assembly;\n    var typeA = ObfuscationTypeMapper.GetTypeByOriginalFullName(ass, "MyClassA");\n    // ...\n  }\n}\n\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-manually-maintain-mapping-between-original-names-and-types",children:"3. Manually Maintain Mapping Between Original Names and Types"}),"\n",(0,s.jsx)(n.p,{children:"Use code similar to the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'\nclass NotReflectionFind\n{\n  private static readonly Dictionary<string, Type> _types = new Dictionary<string, Type>{\n    {"A", typeof(A)},\n    {"B", typeof(B)},\n    // ...\n\n  };\n\n  public static Type FindType(string name)\n  {\n    return _types.TryGetValue(name, out var type) ? type : null;\n  }\n}\n\n\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);