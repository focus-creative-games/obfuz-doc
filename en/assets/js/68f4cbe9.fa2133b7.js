"use strict";(self.webpackChunkobfuz=self.webpackChunkobfuz||[]).push([[5186],{548:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"manual/field-encryption","title":"Field Encryption","description":"Encrypting field values can effectively prevent malicious attackers from using memory modification techniques to protect code security.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/field-encryption.md","sourceDirName":"manual","slug":"/manual/field-encryption","permalink":"/en/docs/manual/field-encryption","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manual/field-encryption.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Remove Const Fields","permalink":"/en/docs/manual/remove-const-field"},"next":{"title":"Eval Stack Obfuscation","permalink":"/en/docs/manual/eval-stack-obfuscation"}}');var l=t(4848),r=t(8453);const s={},c="Field Encryption",d={},a=[{value:"Supported Variable Types",id:"supported-variable-types",level:2},{value:"Implementation Principle",id:"implementation-principle",level:2},{value:"Settings",id:"settings",level:2},{value:"Encryption Level",id:"encryption-level",level:2},{value:"EncryptFieldAttribute",id:"encryptfieldattribute",level:2},{value:"Rule Files",id:"rule-files",level:2},{value:"assembly",id:"assembly",level:3},{value:"type",id:"type",level:3},{value:"field",id:"field",level:3}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"field-encryption",children:"Field Encryption"})}),"\n",(0,l.jsx)(n.p,{children:"Encrypting field values can effectively prevent malicious attackers from using memory modification techniques to protect code security."}),"\n",(0,l.jsx)(n.h2,{id:"supported-variable-types",children:"Supported Variable Types"}),"\n",(0,l.jsx)(n.p,{children:"Currently supports encryption of class static variables and member variables, but does not support encryption of ordinary temporary variables within functions. Supported field types for encryption are:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"int, uint"}),"\n",(0,l.jsx)(n.li,{children:"long, ulong"}),"\n",(0,l.jsx)(n.li,{children:"IntPtr, UIntPtr"}),"\n",(0,l.jsx)(n.li,{children:"float"}),"\n",(0,l.jsx)(n.li,{children:"double"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"implementation-principle",children:"Implementation Principle"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Fields are encrypted using ",(0,l.jsx)(n.code,{children:"EncryptionService<Scope>::Encrypt"})," before writing"]}),"\n",(0,l.jsxs)(n.li,{children:["Fields are decrypted using ",(0,l.jsx)(n.code,{children:"EncryptionService<Scope>::Decrypt"})," before reading"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Obfuz will modify all read and write operations for encrypted fields in all assemblies. This encryption process is completely transparent to the assemblies. Obfuz's field encryption algorithm ensures that 0 values map to 0 values."}),"\n",(0,l.jsxs)(n.p,{children:["Note that Obfuz only guarantees that encryption and decryption operations are performed when reading and writing encrypted fields in code. If accessed through reflection, the encrypted variables are directly operated on, which will cause errors.\nMonoBehaviour, ScriptableObject, and serialization libraries like NewtonsoftJson rely heavily on reflection to read and assign field values, making them incompatible with field encryption.\nTherefore, ",(0,l.jsx)(n.strong,{children:"do not configure these fields as encrypted"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"settings",children:"Settings"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"ObfuzSettings.FieldEncryptSettings"})," contains constant encryption related settings, detailed documentation can be found in ",(0,l.jsx)(n.a,{href:"./configuration",children:"Configuration"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"encryption-level",children:"Encryption Level"}),"\n",(0,l.jsxs)(n.p,{children:["The encryption level affects the ",(0,l.jsx)(n.code,{children:"ops"})," parameter passed when calling ",(0,l.jsx)(n.code,{children:"EncryptionService<Scope>::Encrypt"}),". For detailed introduction to the ops parameter, see the documentation ",(0,l.jsx)(n.a,{href:"./encryption",children:"Encryption"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["The encryption level value range is ",(0,l.jsx)(n.code,{children:"[1-4]"}),". During encryption, the number of ops generated equals the encryption level value. Simply enabling constant encryption can effectively prevent cracking. The encryption level size does not significantly improve the difficulty of anti-cracking, so it is recommended to default to 1."]}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"FieldEncryptSettings.EncryptionLevel"})," field can set the global default encryption level."]}),"\n",(0,l.jsx)(n.h2,{id:"encryptfieldattribute",children:"EncryptFieldAttribute"}),"\n",(0,l.jsxs)(n.p,{children:["EncryptFieldAttribute provides a convenient way to mark fields as encrypted fields in code. For detailed documentation, see ",(0,l.jsx)(n.a,{href:"./customattributes",children:"Obfuz CustomAttributes"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["It has higher priority than Obfuscation Pass rules and ",(0,l.jsx)(n.code,{children:"[ObfuzIgnore]"}),". As long as a field has the ",(0,l.jsx)(n.code,{children:"[EncryptField]"})," attribute, it will still be encrypted even if the field and its containing type have the ",(0,l.jsx)(n.code,{children:"[ObfuzIgnore]"})," attribute."]}),"\n",(0,l.jsx)(n.p,{children:"Example code:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"\n[ObfuzIgnore]\nclass A\n{\n  [EncryptField]\n  public int x1; // Variable x1 will still be encrypted, ignoring [ObfuzIgnore] on the type\n  \n  [ObfuzIgnore]\n  [EncryptField]\n  public int x2; // Variable x2 will still be encrypted, ignoring [ObfuzIgnore] on the field\n\n  public int y; // Variable y will not be encrypted, nor will it be subject to any obfuscation or encryption passes\n}\n\n"})}),"\n",(0,l.jsx)(n.h2,{id:"rule-files",children:"Rule Files"}),"\n",(0,l.jsxs)(n.p,{children:["Since field encryption affects field read/write performance, ",(0,l.jsx)(n.strong,{children:"no fields are encrypted by default"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["Since encrypted fields are generally very few, by design it has higher priority than Obfuscation Pass rules, but lower than ",(0,l.jsx)(n.code,{children:"[ObfuzIgnore]"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["Supports fine-grained control of field encryption scope and effects through rule files. The ",(0,l.jsx)(n.code,{children:"FieldEncryptSettings.RuleFiles"})," option can configure 0-N rule files.\nRule file relative paths are from the project directory, valid rule file paths look like: ",(0,l.jsx)(n.code,{children:"Assets/XXX/YYY.xml"}),"."]}),"\n",(0,l.jsx)(n.p,{children:"Configuration example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'\n<?xml version="1.0" encoding="UTF-8"?>\n\n<obfuz>\n    <assembly name="Obfus1">\n        <type name="*">\n            <field name="a"/>\n            <field name="b"/>\n        </type>\n    </assembly>\n</obfuz>\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Top-level tag must be obfuz"}),"\n",(0,l.jsx)(n.li,{children:"Second-level tags must be assembly"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"assembly",children:"assembly"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Attribute"}),(0,l.jsx)(n.th,{children:"Nullable"}),(0,l.jsx)(n.th,{children:"Default"}),(0,l.jsx)(n.th,{children:"Description"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"name"}),(0,l.jsx)(n.td,{children:"No"}),(0,l.jsx)(n.td,{}),(0,l.jsx)(n.td,{children:"Assembly name, must be in the obfuscated assembly list"})]})})]}),"\n",(0,l.jsx)(n.p,{children:"Assembly's child elements can only be type."}),"\n",(0,l.jsx)(n.h3,{id:"type",children:"type"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Attribute"}),(0,l.jsx)(n.th,{children:"Nullable"}),(0,l.jsx)(n.th,{children:"Default"}),(0,l.jsx)(n.th,{children:"Description"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"name"}),(0,l.jsx)(n.td,{children:"No"}),(0,l.jsx)(n.td,{}),(0,l.jsxs)(n.td,{children:["Type name wildcard string, if empty means match all types. Nested types use ",(0,l.jsx)(n.code,{children:"/"})," to separate the declaring type and enclosed subtype, like ",(0,l.jsx)(n.code,{children:"test.ClassA/ClassB"}),"."]})]})})]}),"\n",(0,l.jsx)(n.p,{children:"Since field encryption can only act on fields, type's child elements can only be field."}),"\n",(0,l.jsx)(n.h3,{id:"field",children:"field"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Attribute"}),(0,l.jsx)(n.th,{children:"Nullable"}),(0,l.jsx)(n.th,{children:"Default"}),(0,l.jsx)(n.th,{children:"Description"})]})}),(0,l.jsx)(n.tbody,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"name"}),(0,l.jsx)(n.td,{children:"No"}),(0,l.jsx)(n.td,{}),(0,l.jsx)(n.td,{children:"Name of the field to be encrypted. Field name wildcard string, if empty means match all types"})]})})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var i=t(6540);const l={},r=i.createContext(l);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);