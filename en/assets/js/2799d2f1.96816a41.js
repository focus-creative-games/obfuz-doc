"use strict";(self.webpackChunkobfuz=self.webpackChunkobfuz||[]).push([[4849],{1894:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"manual/encryption","title":"Encryption","description":"Encryption is the core mechanism of Obfuz. Most Obfuscation Passes are related to encryption for the following reasons:","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/encryption.md","sourceDirName":"manual","slug":"/manual/encryption","permalink":"/en/docs/manual/encryption","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manual/encryption.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Assemblies","permalink":"/en/docs/manual/assembly"},"next":{"title":"Method Body Obfuscation","permalink":"/en/docs/manual/method-body-obfuscation"}}');var r=t(4848),o=t(8453);const c={},s="Encryption",a={},l=[{value:"IEncryptor",id:"iencryptor",level:2},{value:"Encryption Instruction Group ops",id:"encryption-instruction-group-ops",level:2},{value:"EncryptionVM",id:"encryptionvm",level:2},{value:"Encryption Instruction Set",id:"encryption-instruction-set",level:3},{value:"Generating Encryption Instruction Set",id:"generating-encryption-instruction-set",level:3},{value:"Generating EncryptionVM Code",id:"generating-encryptionvm-code",level:3},{value:"EncryptionService",id:"encryptionservice",level:2},{value:"Initializing Encryptor",id:"initializing-encryptor",level:3},{value:"EncryptionScope",id:"encryptionscope",level:2},{value:"Secret Key",id:"secret-key",level:2},{value:"salt",id:"salt",level:2},{value:"SecretSettings.RandomSeed",id:"secretsettingsrandomseed",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"encryption",children:"Encryption"})}),"\n",(0,r.jsx)(n.p,{children:"Encryption is the core mechanism of Obfuz. Most Obfuscation Passes are related to encryption for the following reasons:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Features like constant encryption that directly involve data encryption functionality inevitably need to use encryption-related mechanisms"}),"\n",(0,r.jsx)(n.li,{children:"Obfuscation passes like function call obfuscation use delayed (i.e., when executing that code for the first time) decryption of some key parameters to prevent offline cracking"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"iencryptor",children:"IEncryptor"}),"\n",(0,r.jsx)(n.p,{children:"Obfuz builds the entire encryption mechanism on a basic encryption interface IEncryptor."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"\nnamespace Obfuz\n{\n    public interface IEncryptor\n    {\n        int OpCodeCount { get; }\n\n        void EncryptBlock(byte[] data, int ops, int salt);\n        void DecryptBlock(byte[] data, int ops, int salt);\n\n        int Encrypt(int value, int opts, int salt);\n        int Decrypt(int value, int opts, int salt);\n\n        long Encrypt(long value, int opts, int salt);\n        long Decrypt(long value, int opts, int salt);\n\n        float Encrypt(float value, int opts, int salt);\n        float Decrypt(float value, int opts, int salt);\n\n        double Encrypt(double value, int opts, int salt);\n        double Decrypt(double value, int opts, int salt);\n\n        byte[] Encrypt(byte[] value, int offset, int length, int opts, int salt);\n        byte[] Decrypt(byte[] value, int offset, int byteLength, int ops, int salt);\n\n        byte[] Encrypt(string value, int ops, int salt);\n        string DecryptString(byte[] value, int offset, int stringBytesLength, int ops, int salt);\n    }\n}\n\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Any encryption or decryption operation involves 3 pieces of data:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"data: original data or encrypted data"}),"\n",(0,r.jsx)(n.li,{children:"ops: encryption or decryption operations"}),"\n",(0,r.jsx)(n.li,{children:"salt: additional random parameter"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"encryption-instruction-group-ops",children:"Encryption Instruction Group ops"}),"\n",(0,r.jsx)(n.p,{children:"To increase cracking difficulty, Obfuz does not use fixed encryption code, but pre-generates a fixed MaxOpCount number (default 256, customizable) of encryption instructions.\nFor each encryption object, a set of random encryption (or decryption) instructions op1, op2, .. opn is generated."}),"\n",(0,r.jsxs)(n.p,{children:["To simplify implementation while avoiding excessive performance impact, we limit encryption operations to no more than 4, which can generally be encoded as an integer, i.e., the ",(0,r.jsx)(n.code,{children:"int ops"})," parameter in Encrypt or Decrypt functions."]}),"\n",(0,r.jsx)(n.p,{children:"The final ops calculation method is as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"\nint GenerateOps(uint[] opArr)\n{\n  uint ops = 0;\n  for (int i = opArr.Length - 1; i >= 0; i--)\n  {\n    ops *= MaxOpCount;\n    ops |= opArr[i];\n  }\n  return (int)ops;\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Since decryption is the reverse operation of encryption, using reverse encoding ops algorithm facilitates runtime decryption to decode ops in forward order, improving runtime efficiency, as runtime decryption operations are much more frequent than encryption operations."}),"\n",(0,r.jsx)(n.h2,{id:"encryptionvm",children:"EncryptionVM"}),"\n",(0,r.jsx)(n.p,{children:"The encryption service in Obfuz needs to meet the following requirements:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Implement all interfaces in IEncryptor."}),"\n",(0,r.jsx)(n.li,{children:"Support encryption instruction group ops mechanism."}),"\n",(0,r.jsx)(n.li,{children:"Polymorphism, i.e., each developer can generate unique encryption code, increasing cracking difficulty."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"We achieve these goals by generating EncryptionVM based on a randomization seed."}),"\n",(0,r.jsx)(n.h3,{id:"encryption-instruction-set",children:"Encryption Instruction Set"}),"\n",(0,r.jsx)(n.p,{children:"To support the encryption instruction group ops mechanism, EncryptionVM needs to contain a fixed set of encryption instructions."}),"\n",(0,r.jsx)(n.p,{children:"EncryptionVM supports the following encryption instruction primitives:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Add"}),"\n",(0,r.jsx)(n.li,{children:"Multiple"}),"\n",(0,r.jsx)(n.li,{children:"Xor"}),"\n",(0,r.jsx)(n.li,{children:"BitRotate"}),"\n",(0,r.jsx)(n.li,{children:"AddRotateXor"}),"\n",(0,r.jsx)(n.li,{children:"AddXorRotate"}),"\n",(0,r.jsx)(n.li,{children:"MultipleRotateXor"}),"\n",(0,r.jsx)(n.li,{children:"MultipleXorRotate"}),"\n",(0,r.jsx)(n.li,{children:"XorAddRotate"}),"\n",(0,r.jsx)(n.li,{children:"XorMultipleRotate"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each encryption instruction primitive has some randomization parameters, ensuring that every encryption instruction is different."}),"\n",(0,r.jsx)(n.h3,{id:"generating-encryption-instruction-set",children:"Generating Encryption Instruction Set"}),"\n",(0,r.jsx)(n.p,{children:"Obfuz uses a deterministic random algorithm to generate the encryption instruction set based on an initial random seed."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"EncryptionVMSettings.CodeGenerationSecretKey"})," configures this initial randomization seed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"EncryptionVMSettings.EncryptionOpCodeCount"})," configures the number of instructions in the encryption instruction set."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["EncryptionOpCodeCount must be a power of 2 (like 64, 128, 256, 1024), with a default value of 256. The minimum value is 64, and while there's no maximum limit, it's not recommended to exceed 1024 as it would cause the generated ",(0,r.jsx)(n.code,{children:"GeneratedEncryptionVirtualMachine"})," class code to be too large."]}),"\n",(0,r.jsx)(n.p,{children:"The generation algorithm randomly selects the encryption instruction primitive used by each instruction and the randomization parameters for that encryption primitive."}),"\n",(0,r.jsx)(n.h3,{id:"generating-encryptionvm-code",children:"Generating EncryptionVM Code"}),"\n",(0,r.jsxs)(n.p,{children:["Run the menu ",(0,r.jsx)(n.code,{children:"Obfuz/GenerateEncryptionVM"})," to generate encryption virtual machine code. Configure the output code file path for the ",(0,r.jsx)(n.code,{children:"GeneratedEncryptionVirtualMachine"})," class in ",(0,r.jsx)(n.code,{children:"EncryptionVMSettings.CodeOutputPath"}),".\nThe default generated code file is ",(0,r.jsx)(n.code,{children:"Assets/Obfuz/GeneratedEncryptionVirtualMachine.cs"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Generally, GeneratedEncryptionVirtualMachine needs to be placed in AOT assemblies. This not only improves encryption performance but also takes advantage of il2cpp's characteristic of compiling code to machine instructions, increasing cracking difficulty."}),"\n",(0,r.jsx)(n.p,{children:"If there are no AOT obfuscated assemblies, GeneratedEncryptionVirtualMachine can also be placed in hot update assemblies, achieving maximum flexibility with different encryption virtual machines for each hot update code release. However, placing it in hot update code not only leads to poor encryption performance but is also easily reverse-engineered, so this is not recommended."}),"\n",(0,r.jsxs)(n.p,{children:["It's recommended to modify ",(0,r.jsx)(n.code,{children:"CodeGenerationSecretKey"})," each time a new main package is released to generate a brand new EncryptionVM, increasing cracking difficulty. If code hot update technology is used and ",(0,r.jsx)(n.code,{children:"GeneratedEncryptionVirtualMachine"})," is in AOT assemblies, do not modify ",(0,r.jsx)(n.code,{children:"CodeGenerationSecretKey"})," when releasing hot update code, otherwise it will cause decryption code errors in obfuscated hot update assemblies!"]}),"\n",(0,r.jsx)(n.h2,{id:"encryptionservice",children:"EncryptionService"}),"\n",(0,r.jsxs)(n.p,{children:["Obfuz provides unified encryption and decryption services through the EncryptionService class. Its implementation is simple, with an ",(0,r.jsx)(n.code,{children:"IEncryptor _encryptor"})," variable that implements specific encryption and decryption services by forwarding calls to interfaces in ",(0,r.jsx)(n.code,{children:"_encryptor"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Partial code excerpt from EncryptionService:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"\n\nnamespace Obfuz\n{\n\n    public static class EncryptionService<T> where T : IEncryptionScope\n    {\n        // for compatibility with Mono because Mono will raise FieldAccessException when try access private field\n        public static IEncryptor _encryptor;\n\n        public static IEncryptor Encryptor\n        {\n            get => _encryptor;\n            set { _encryptor = value; }\n        }\n\n        public static void EncryptBlock(byte[] data, int ops, int salt)\n        {\n            _encryptor.EncryptBlock(data, ops, salt);\n        }\n\n        public static void DecryptBlock(byte[] data, int ops, int salt)\n        {\n            _encryptor.DecryptBlock(data, ops, salt);\n        }\n\n        // ....\n    }\n}\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Taking constant encryption as an example, ",(0,r.jsx)(n.code,{children:"int a = 5;"})," becomes ",(0,r.jsx)(n.code,{children:"int a = Obfuz.EncryptionService<Obfuz.DefaultStaticSecretScope>.Decrypt(11231312, 98978274, 2342342)"})," after constant encryption."]}),"\n",(0,r.jsx)(n.h3,{id:"initializing-encryptor",children:"Initializing Encryptor"}),"\n",(0,r.jsxs)(n.p,{children:["Generally, EncryptionService.Encryptor is assigned a ",(0,r.jsx)(n.code,{children:"GeneratedEncryptionVirtualMachine"})," instance, example code as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'\n    [ObfuzIgnore]\n    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]\n    private static void SetUpStaticSecret()\n    {\n        EncryptionService<DefaultStaticEncryptionScope>.Encryptor = new GeneratedEncryptionVirtualMachine(Resources.Load<TextAsset>("Obfuz/defaultStaticSecretKey").bytes);\n        // ... Initialize other EncryptionScopes\n    }\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["GeneratedEncryptionVirtualMachine requires a 1024-byte ",(0,r.jsx)(n.code,{children:"byte[]"})," key parameter. Since this key is quite long, instead of generating it directly, it's calculated from an initial key string through a hash algorithm."]}),"\n",(0,r.jsxs)(n.p,{children:["Obfuz calls the ",(0,r.jsx)(n.code,{children:"Obfuz.Utils.KeyGenerator::GenerateKey"})," function to generate keys, code as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"namespace Obfuz.Utils\n{\n    public static class KeyGenerator\n    {\n        public static byte[] GenerateKey(string initialString, int keyLength)\n        {\n            byte[] initialBytes = Encoding.UTF8.GetBytes(initialString);\n            using (var sha512 = SHA512.Create())\n            {\n                byte[] hash = sha512.ComputeHash(initialBytes);\n                byte[] key = new byte[keyLength];\n                int bytesCopied = 0;\n                while (bytesCopied < key.Length)\n                {\n                    if (bytesCopied > 0)\n                    {\n                        // Hash the previous hash value again to generate more data\n                        hash = sha512.ComputeHash(hash);\n                    }\n                    int bytesToCopy = Math.Min(hash.Length, key.Length - bytesCopied);\n                    Buffer.BlockCopy(hash, 0, key, bytesCopied, bytesToCopy);\n                    bytesCopied += bytesToCopy;\n                }\n                return key;\n            }\n        }\n\n        // ...\n    }\n}\n\n"})}),"\n",(0,r.jsx)(n.h2,{id:"encryptionscope",children:"EncryptionScope"}),"\n",(0,r.jsx)(n.p,{children:"Game projects want to use multiple keys to increase cracking difficulty. Also, if code hot updates are used in a project, it's very likely that hot update code should use different encryption keys from AOT, and these keys should be loadable after hot updates are completed, not necessarily at startup.\nObfuz implements this functionality through EncryptionScope."}),"\n",(0,r.jsxs)(n.p,{children:["By setting different ",(0,r.jsx)(n.code,{children:"IEncryptor"})," instances for different ",(0,r.jsx)(n.code,{children:"EncryptionService<{EncryptionScope}>"})," at runtime, multiple different keys can be used, example code as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'\n    [ObfuzIgnore]\n    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]\n    private static void SetUpStaticSecret()\n    {\n        EncryptionService<DefaultStaticEncryptionScope>.Encryptor = new GeneratedEncryptionVirtualMachine(Resources.Load<TextAsset>("Obfuz/defaultStaticSecretKey").bytes);\n        // Set Encryptors for other static EncryptionScopes\n        // ...\n    }\n\n    private static void SetUpDynamicSecret()\n    {\n        EncryptionService<DefaultDynamicEncryptionScope>.Encryptor = new GeneratedEncryptionVirtualMachine(Resources.Load<TextAsset>("Obfuz/defaultDynamicSecretKey").bytes);\n        // Set Encryptors for other dynamic EncryptionScopes\n        // ...\n    }\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Each assembly can only correspond to one EncryptionScope, i.e., you cannot use EncryptionScopeA for part of the code in an assembly and EncryptionScopeB for another part. Each obfuscated assembly uses ",(0,r.jsx)(n.code,{children:"DefaultStaticEncryptionScope"})," by default,\ni.e., uses the ",(0,r.jsx)(n.code,{children:"SecretSettings.DefaultStaticSecretKey"})," key. If an assembly name is added to the ",(0,r.jsx)(n.code,{children:"SecretSettings.AssembliesUseDynamicSecretKeys"})," list, that assembly uses ",(0,r.jsx)(n.code,{children:"DefaultDynamicEncryptionScope"}),"."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"EncryptionService<DefaultStaticEncryptionScope>.Encryptor"})," must be initialized with DefaultStaticSecretKey,\n",(0,r.jsx)(n.code,{children:"EncryptionService<DefaultDynamicEncryptionScope>.Encryptor"})," must be initialized with DefaultDynamicSecretKey,\nthese two cannot be mixed!"]})}),"\n",(0,r.jsx)(n.h2,{id:"secret-key",children:"Secret Key"}),"\n",(0,r.jsx)(n.p,{children:"The current version only supports two keys: defaultStaticSecretKey and defaultDynamicSecretKey. Future versions will support any number of keys."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"DefaultStaticSecretKey"})," and ",(0,r.jsx)(n.code,{children:"DefaultDynamicSecretKey"})," can be configured in ",(0,r.jsx)(n.code,{children:"ObfuzSettings.SecretSettings"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The menu ",(0,r.jsx)(n.code,{children:"Obfuz/GenerateSecretKey"})," will generate defaultStaticSecretKey.bytes and defaultDynamicSecretKey.bytes files for these two keys. The output directory for key files can be configured in ",(0,r.jsx)(n.code,{children:"SecretSettings.SecretKeyOutputPath"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If some AOT assemblies are obfuscated, since code in AOT assemblies may be executed very early, if Encryptor is not set for their corresponding ",(0,r.jsx)(n.code,{children:"EncryptionService<{EncryptionScope}>"})," before executing obfuscated or encrypted code in these assemblies,\nruntime exceptions will occur. It's recommended to execute ",(0,r.jsx)(n.code,{children:"EncryptionService<{EncryptionScope}>.Encryptor"})," initialization code as early as possible. A reasonable approach is to use ",(0,r.jsx)(n.code,{children:"[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]"}),"\nto run EncryptionService initialization code after CLR (il2cpp or mono) runtime loads all assemblies."]}),"\n",(0,r.jsxs)(n.p,{children:["Obviously, ",(0,r.jsx)(n.code,{children:"SetUpStaticSecret"})," code should not be obfuscated, as EncryptionService is not yet initialized at that time, which would lead to infinite recursion. However, ",(0,r.jsx)(n.code,{children:"SetUpDynamicSecret"})," can be obfuscated, so it's generally called only after certain conditions are met (such as after hot updates are completed)."]}),"\n",(0,r.jsx)(n.h2,{id:"salt",children:"salt"}),"\n",(0,r.jsxs)(n.p,{children:["The salt in Encrypt or Decrypt is a randomly generated parameter with a value range of ",(0,r.jsx)(n.code,{children:"[int.MinValue, int.MaxValue]"}),". It serves as an additional parameter to increase the complexity of encryption and decryption operations."]}),"\n",(0,r.jsx)(n.h2,{id:"secretsettingsrandomseed",children:"SecretSettings.RandomSeed"}),"\n",(0,r.jsx)(n.p,{children:"RandomSeed does not directly participate in the encryption/decryption process, but it's used to generate random ops, salt, and other scenarios requiring randomization."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>s});var i=t(6540);const r={},o=i.createContext(r);function c(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);