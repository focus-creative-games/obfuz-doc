"use strict";(self.webpackChunkobfuz=self.webpackChunkobfuz||[]).push([[5829],{7576:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"manual/call-obfuscation","title":"Function Call Obfuscation","description":"Function call obfuscation disguises how functions (static, member, or virtual) are called in code. After decompilation, it\'s impossible to directly know which function is being executed, effectively protecting code security.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/call-obfuscation.md","sourceDirName":"manual","slug":"/manual/call-obfuscation","permalink":"/en/docs/manual/call-obfuscation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manual/call-obfuscation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Expression Obfuscation","permalink":"/en/docs/manual/expr-obfuscation"},"next":{"title":"Control Flow Obfuscation","permalink":"/en/docs/manual/control-flow-obfuscation"}}');var i=t(4848),l=t(8453);const c={},d="Function Call Obfuscation",r={},o=[{value:"Implementation Principle",id:"implementation-principle",level:2},{value:"Settings",id:"settings",level:2},{value:"Proxy Mode",id:"proxy-mode",level:2},{value:"Encryption Level",id:"encryption-level",level:2},{value:"Rule Files",id:"rule-files",level:2},{value:"whitelist",id:"whitelist",level:3},{value:"assembly",id:"assembly",level:4},{value:"type",id:"type",level:4},{value:"method",id:"method",level:4},{value:"global",id:"global",level:3},{value:"assembly",id:"assembly-1",level:3},{value:"type",id:"type-1",level:3},{value:"method",id:"method-1",level:3}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"function-call-obfuscation",children:"Function Call Obfuscation"})}),"\n",(0,i.jsx)(n.p,{children:"Function call obfuscation disguises how functions (static, member, or virtual) are called in code. After decompilation, it's impossible to directly know which function is being executed, effectively protecting code security."}),"\n",(0,i.jsx)(n.h2,{id:"implementation-principle",children:"Implementation Principle"}),"\n",(0,i.jsxs)(n.p,{children:["For each function call ",(0,i.jsx)(n.code,{children:"xxx Foo(T1 p1, T2 p2, ...)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Group called functions by their signatures, assigning each function a unique index within its group."}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"EncryptionService<Scope>::Encrypt(int value, int ops, int salt)"})," to calculate an encryptedIndex from the index."]}),"\n",(0,i.jsxs)(n.li,{children:["At the function call site, first call ",(0,i.jsx)(n.code,{children:"EncryptionService<Scope>::Decrypt(int value, int ops, int salt)"})," to decrypt and get the original index."]}),"\n",(0,i.jsxs)(n.li,{children:["Replace the original function call with ",(0,i.jsx)(n.code,{children:"xxx $Dispatch(T1 p1, T2 p2, ..., int index)"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The encryptedIndex is decrypted only when executing that code location. After decompilation, it's impossible to directly know which function is called, effectively increasing the difficulty of code cracking!"}),"\n",(0,i.jsx)(n.h2,{id:"settings",children:"Settings"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ObfuzSettings.CallEncryptSettings"})," contains settings related to constant encryption. See ",(0,i.jsx)(n.a,{href:"./configuration",children:"Configuration"})," for details."]}),"\n",(0,i.jsx)(n.h2,{id:"proxy-mode",children:"Proxy Mode"}),"\n",(0,i.jsx)(n.p,{children:"There are multiple methods to obfuscate function calls."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Mode"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Dispatch"}),(0,i.jsx)(n.td,{children:"Converts function calls to indirect calls through another dispatch function. The index of the dispatch function determines the actual function called. The index value is encrypted and only decrypted at runtime, effectively preventing attackers from analyzing call relationships."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Delegate"}),(0,i.jsxs)(n.td,{children:["Converts function calls to precomputed delegates. Delegate objects are bound to elements at specific indexes in a ",(0,i.jsx)(n.code,{children:"delegate[]"})," array at runtime. The index value is encrypted and only decrypted at runtime, effectively preventing attackers from analyzing call relationships."]})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"There's no significant difference in obfuscation level or runtime performance between Delegate and Dispatch modes. The advantage of Delegate over Dispatch is that the generated obfuscated code is more stable, with smaller differences when code changes."}),"\n",(0,i.jsx)(n.p,{children:"Dispatch mode is recommended for most projects. For HybridCLR premium users, reducing code changes can reduce the number of functions switched to interpreted execution, improving DHE performance, so Delegate mode is recommended."}),"\n",(0,i.jsx)(n.h2,{id:"encryption-level",children:"Encryption Level"}),"\n",(0,i.jsxs)(n.p,{children:["The encryption level affects the ",(0,i.jsx)(n.code,{children:"ops"})," parameter passed to ",(0,i.jsx)(n.code,{children:"EncryptionService<Scope>::Encrypt"}),". See ",(0,i.jsx)(n.a,{href:"./encryption",children:"Encryption"})," for detailed information about the ops parameter."]}),"\n",(0,i.jsxs)(n.p,{children:["The encryption level ranges from ",(0,i.jsx)(n.code,{children:"[1-4]"}),". During encryption, the number of ops generated equals the encryption level value. As long as constant encryption is enabled, it effectively prevents cracking. Higher encryption levels provide minimal additional protection against cracking. The default value of 1 is recommended."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"CallEncryptSettings.EncryptionLevel"})," field can set the global default encryption level."]}),"\n",(0,i.jsx)(n.h2,{id:"rule-files",children:"Rule Files"}),"\n",(0,i.jsxs)(n.p,{children:["By default, Obfuz encrypts all function calls, but it also supports rule files to precisely control the scope and effect of constant encryption. The ",(0,i.jsx)(n.code,{children:"CallEncryptSettings.RuleFiles"})," option can configure 0-N rule files.\nRule files are relative to the project directory. Valid rule file paths look like: ",(0,i.jsx)(n.code,{children:"Assets/XXX/YYY.xml"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Configuration example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" encoding="UTF-8"?>\n\n<obfuz>\n  <whitelist>\n    <assembly name="mscorlib" obfuscate="0"/>\n    <assembly name="UnityEngine.*" obfuscate="0"/>\n    \n    <assembly name="Obfus2">\n      <type name="Banana" obfuscate="0"/>\n      <type name="*.TestTypeAllMethodNotObfus" obfuscate="0"/>\n      <type name="*.TestTypeSomeMethodNotObfus">\n          <method name="NotObfus*"/>\n      </type>\n    </assembly>\n  </whitelist>\n  \n  <global obfuscationLevel="Basic">\n\n  </global>\n  \n  <assembly name="Obfus2">\n      <type name="*.TestNotObfusTypeAllMethods" obfuscationLevel="None"/>\n      <type name="*.TestNotObfusTypeSomeMethods">\n          <method name="NotObfus*" obfuscationLevel="None"/>\n      </type>\n      <type name="Aaaa.TopClass/SubClass" obfuscationLevel="Advanced">\n      </type>\n  </assembly>\n</obfuz>\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The top-level tag must be ",(0,i.jsx)(n.code,{children:"obfuz"})]}),"\n",(0,i.jsxs)(n.li,{children:["Secondary tags can be ",(0,i.jsx)(n.code,{children:"whitelist"}),", ",(0,i.jsx)(n.code,{children:"global"}),", and ",(0,i.jsx)(n.code,{children:"assembly"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"whitelist",children:"whitelist"}),"\n",(0,i.jsx)(n.p,{children:"The whitelist configures functions that won't be encrypted when called. This setting applies to all assemblies."}),"\n",(0,i.jsx)(n.h4,{id:"assembly",children:"assembly"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Optional"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"None"}),(0,i.jsx)(n.td,{children:"Name as a wildcard expression. If empty, matches all assemblies."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"obfuscate"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Whether to obfuscate calls to functions within this assembly."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The only child element of ",(0,i.jsx)(n.code,{children:"assembly"})," is ",(0,i.jsx)(n.code,{children:"type"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"type",children:"type"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Optional"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"None"}),(0,i.jsxs)(n.td,{children:["Name as a wildcard expression. If empty, matches all types. Nested types use ",(0,i.jsx)(n.code,{children:"/"})," to separate the containing type and nested type, e.g., ",(0,i.jsx)(n.code,{children:"test.ClassA/ClassB"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"obfuscate"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Inherits from assembly's\u540c\u540d field"}),(0,i.jsx)(n.td,{children:"Whether to obfuscate calls to functions within this type."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The only child element of ",(0,i.jsx)(n.code,{children:"type"})," is ",(0,i.jsx)(n.code,{children:"method"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"method",children:"method"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Optional"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"None"}),(0,i.jsx)(n.td,{children:"Name as a wildcard expression. If empty, matches all methods."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"obfuscate"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Inherits from type's\u540c\u540d field"}),(0,i.jsx)(n.td,{children:"Whether to obfuscate calls to this method."})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"global",children:"global"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"global"})," tag defines global default encryption parameters."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Optional"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"obfuscationLevel"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"None"}),(0,i.jsx)(n.td,{children:"Obfuscation level, which can be None, Basic, Advanced, or MostAdvanced."})]})})]}),"\n",(0,i.jsx)(n.h3,{id:"assembly-1",children:"assembly"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Optional"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Assembly name, which must be in the list of obfuscated assemblies."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Others"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Inherits from global\u540c\u540d options"}),(0,i.jsxs)(n.td,{children:["All options from ",(0,i.jsx)(n.code,{children:"global"})," can be used. If not defined, inherits values from ",(0,i.jsx)(n.code,{children:"global"}),"."]})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The only child element of ",(0,i.jsx)(n.code,{children:"assembly"})," is ",(0,i.jsx)(n.code,{children:"type"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"type-1",children:"type"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Optional"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Wildcard string for type names. If empty, matches all types."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Others"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Inherits from assembly\u540c\u540d options"}),(0,i.jsxs)(n.td,{children:["All options from ",(0,i.jsx)(n.code,{children:"global"})," can be used. If not defined, inherits values from ",(0,i.jsx)(n.code,{children:"assembly"}),"."]})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["Since function calls can only appear in function code, the only child element of ",(0,i.jsx)(n.code,{children:"type"})," is ",(0,i.jsx)(n.code,{children:"method"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"method-1",children:"method"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Attribute"}),(0,i.jsx)(n.th,{children:"Optional"}),(0,i.jsx)(n.th,{children:"Default"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"name"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Wildcard string for method names. If empty, matches all methods."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Others"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"Inherits from assembly\u540c\u540d options"}),(0,i.jsxs)(n.td,{children:["All options from ",(0,i.jsx)(n.code,{children:"global"})," can be used. If not defined, inherits values from ",(0,i.jsx)(n.code,{children:"assembly"}),"."]})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>d});var s=t(6540);const i={},l=s.createContext(i);function c(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);