"use strict";(self.webpackChunkobfuz=self.webpackChunkobfuz||[]).push([[4019],{1816:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"manual/incremental-obfuscation-and-hotupdate","title":"Incremental Obfuscation and Hot Update","description":"Obfuz supports incremental obfuscation, with most Obfuscation Passes striving to maintain obfuscation stability.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/manual/incremental-obfuscation-and-hotupdate.md","sourceDirName":"manual","slug":"/manual/incremental-obfuscation-and-hotupdate","permalink":"/en/docs/manual/incremental-obfuscation-and-hotupdate","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/manual/incremental-obfuscation-and-hotupdate.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Run Obfuscation Standalone","permalink":"/en/docs/manual/run-obfuscation-standalonely"},"next":{"title":"Serialization","permalink":"/en/docs/manual/serialization"}}');var s=t(4848),a=t(8453);const o={},l="Incremental Obfuscation and Hot Update",r={},c=[{value:"Obfuscation in Build Pipeline",id:"obfuscation-in-build-pipeline",level:2},{value:"Standalone Obfuscation Execution",id:"standalone-obfuscation-execution",level:2},{value:"Hot Update",id:"hot-update",level:2},{value:"HybridCLR Issues",id:"hybridclr-issues",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"incremental-obfuscation-and-hot-update",children:"Incremental Obfuscation and Hot Update"})}),"\n",(0,s.jsx)(n.p,{children:"Obfuz supports incremental obfuscation, with most Obfuscation Passes striving to maintain obfuscation stability."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Symbol Obfuscation uses symbol mapping files to ensure obfuscation stability."}),"\n",(0,s.jsx)(n.li,{children:"Const Obfuscation uses deterministic random encryption algorithms for each constant."}),"\n",(0,s.jsx)(n.li,{children:"Field Encryption uses deterministic random encryption algorithms for each field."}),"\n",(0,s.jsx)(n.li,{children:"Call Obfuscation uses deterministic random encryption algorithms for each called function."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"obfuscation-in-build-pipeline",children:"Obfuscation in Build Pipeline"}),"\n",(0,s.jsx)(n.p,{children:"Simply keeping settings stable will automatically maintain obfuscation stability in the build pipeline."}),"\n",(0,s.jsx)(n.h2,{id:"standalone-obfuscation-execution",children:"Standalone Obfuscation Execution"}),"\n",(0,s.jsxs)(n.p,{children:["As long as obfuscation settings are not modified, it works the same as obfuscation in the build pipeline and will automatically maintain obfuscation stability. For detailed documentation, see ",(0,s.jsx)(n.a,{href:"./run-obfuscation-standalonely",children:"Run Obfuscation Standalone"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"hot-update",children:"Hot Update"}),"\n",(0,s.jsx)(n.p,{children:"Obfuscation in hot updates follows exactly the same process as standalone obfuscation execution."}),"\n",(0,s.jsx)(n.p,{children:"If incremental obfuscation stability is not a concern, you can modify the following parameters to make the obfuscation results as different as possible for each hot update:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Delete hot update code related configuration sections from the symbol mapping file"}),"\n",(0,s.jsxs)(n.li,{children:["Modify the ",(0,s.jsx)(n.code,{children:"SecretSettings.DefaultDynamicSecretKey"})," field"]}),"\n",(0,s.jsxs)(n.li,{children:["Modify the ",(0,s.jsx)(n.code,{children:"SecretSettings.RandomSeed"})," field"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Modifying ",(0,s.jsx)(n.code,{children:"ConstEncrypSettings.EncryptionLevel"}),", ",(0,s.jsx)(n.code,{children:"FieldEncryptSettings.EncryptionLevel"}),", and ",(0,s.jsx)(n.code,{children:"CallObfusSettings.ObfuscationLevel"})," can also affect obfuscation results.\nHowever, increasing these values will cause encryption performance degradation, so it's recommended not to modify them frequently."]}),"\n",(0,s.jsx)(n.h2,{id:"hybridclr-issues",children:"HybridCLR Issues"}),"\n",(0,s.jsxs)(n.p,{children:["HybridCLR's ",(0,s.jsx)(n.code,{children:"HybridCLR/Generate/All"})," and ",(0,s.jsx)(n.code,{children:"HybridCLR/Generate/LinkXml"})," both generate link.xml based on unobfuscated code, which causes the link.xml generated after obfuscation to have completely ineffective reservations for obfuscated assemblies, since the corresponding names don't exist in the obfuscated assemblies."]}),"\n",(0,s.jsx)(n.p,{children:"The solution is to generate an additional link.xml for the obfuscated assemblies, with the following code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'\n\npublic static class GenerateLinkXmlForObfuscatedAssembly\n{\n    [MenuItem("Obfuz/GenerateLinkXmlForHybridCLR")]\n    public static void GenerateLinkXml()\n    {\n        CompileDllCommand.CompileDllActiveBuildTarget();\n        BuildTarget target = EditorUserBuildSettings.activeBuildTarget;\n        var obfuzSettings = ObfuzSettings.Instance;\n\n        var assemblySearchDirs = new List<string>\n        {\n            SettingsUtil.GetHotUpdateDllsOutputDirByTarget(target),\n        };\n        ObfuscatorBuilder builder = ObfuscatorBuilder.FromObfuzSettings(obfuzSettings, target, true);\n        builder.InsertTopPriorityAssemblySearchPaths(assemblySearchDirs);\n\n        Obfuscator obfuz = builder.Build();\n        obfuz.Run();\n\n\n        List<string> hotfixAssemblies = SettingsUtil.HotUpdateAssemblyNamesExcludePreserved;\n\n        var analyzer = new Analyzer(new PathAssemblyResolver(builder.ObfuscatedAssemblyOutputPath));\n        var refTypes = analyzer.CollectRefs(hotfixAssemblies);\n\n        // LinkXmlWriter in HybridCLR is not public and cannot be accessed in other assemblies, can only be operated through reflection\n        var linkXmlWriter = typeof(SettingsUtil).Assembly.GetType("HybridCLR.Editor.Link.LinkXmlWriter");\n        var writeMethod = linkXmlWriter.GetMethod("Write", BindingFlags.Public | BindingFlags.Instance);\n        var instance = Activator.CreateInstance(linkXmlWriter);\n        string linkXmlOutputPath = $"{Application.dataPath}/Obfuz/link.xml";\n        writeMethod.Invoke(instance, new object[] { linkXmlOutputPath, refTypes });\n        Debug.Log($"[GenerateLinkXmlForObfuscatedAssembly] output:{linkXmlOutputPath}");\n        AssetDatabase.Refresh();\n    }\n}\n\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Before building the game, be sure to run ",(0,s.jsx)(n.code,{children:"Obfuz/GenerateLinkXmlForHybridCLR"})," first, then run ",(0,s.jsx)(n.code,{children:"HybridCLR/Generate/All"}),", otherwise trimming exceptions will occur."]})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);